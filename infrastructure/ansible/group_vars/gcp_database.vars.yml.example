# GCP Database Server Variables
#
# COPY THIS FILE AND FILL IN YOUR VALUES:
#   mkdir -p group_vars/gcp_database_servers
#   cp group_vars/gcp_database.vars.yml.example group_vars/gcp_database_servers/vars.yml
#
# IMPORTANT: The directory MUST be named group_vars/gcp_database_servers/ to match
# the inventory group 'gcp_database_servers' in inventory/gcp_database.yml.
# Using group_vars/gcp_database/ (wrong name) will silently use role defaults
# instead of your values -- GCS backup and encryption will be disabled!
#
# For secrets (passwords, keys), use a separate vault.yml file.
# See gcp_database.vault.yml.example for the vault template.

---
# ============================================================
# GCP PROJECT CONFIGURATION
# ============================================================

# Your GCP project ID (required)
gcp_project: "your-gcp-project-id"

# GCP region and zone
gcp_region: "us-east1"
gcp_zone: "us-east1-b"

# ============================================================
# VM PROVISIONING
# ============================================================

# Whether to provision a new VM or use an existing one
# Set to false if VM already exists and you just want to configure PostgreSQL
gcp_vm_provision: true

# VM instance name
gcp_vm_name: "m2s-database"

# Machine type - adjust based on your needs
# e2-micro: Development/testing (1 vCPU, 1GB RAM)
# e2-small: Small production (2 vCPU, 2GB RAM)
# e2-medium: Medium production (2 vCPU, 4GB RAM)
gcp_machine_type: "e2-small"

# Boot disk size (GB) - adjust for your data needs
gcp_boot_disk_size_gb: 20

# Static IP name (optional - comment out for ephemeral IP)
# gcp_static_ip_name: "m2s-database-ip"

# ============================================================
# NETWORK & SECURITY
# ============================================================

# VPC network (use 'default' or your custom VPC)
gcp_network: "default"

# Whether to allow SSH access (recommend: true for initial setup)
gcp_allow_ssh: true

# SSH source ranges - CENTRALLY MANAGED
# Admin IPs are defined in all.yml as the SINGLE SOURCE OF TRUTH
# See docs/runbooks/ansible-playbook-guide.md for instructions on adding co-webmasters
gcp_ssh_allowed_sources: "{{ admin_ssh_ips }}"

# SSH public keys - CENTRALLY MANAGED
# Admin SSH keys are defined in all.yml - this references that centralized list
# CRITICAL: You MUST define admin_ssh_keys in all.yml before deploying!
# Format: "username:ssh-type key-data username@hostname"
#
# NOTE: Jinja2's regex_replace cannot safely access dict attributes like .user and .key.
#       Use the explicit index-based mapping below, or implement a custom filter if you
#       need automatic formatting.
# CRITICAL: You MUST have at least one admin defined in admin_ssh_keys in all.yml!
#           The first line (admin_ssh_keys[0]) will cause a runtime error if the list is empty.
# IMPORTANT: Add this validation to your playbook before using this vars file:
#   - name: Validate admin SSH keys exist
#     ansible.builtin.assert:
#       that:
#         - admin_ssh_keys is defined
#         - admin_ssh_keys | length >= 1
#       fail_msg: "admin_ssh_keys must be defined in all.yml with at least one entry"
gcp_ssh_public_keys: "{{ [admin_ssh_keys[0].user + ':' + admin_ssh_keys[0].key] if (admin_ssh_keys is defined and admin_ssh_keys | length > 0) else [] }}"
  # Uncomment ONLY if you have 2+ admins defined in admin_ssh_keys:
  # - "{{ admin_ssh_keys[1].user }}:{{ admin_ssh_keys[1].key }}"
  # Uncomment ONLY if you have 3+ admins defined in admin_ssh_keys:
  # - "{{ admin_ssh_keys[2].user }}:{{ admin_ssh_keys[2].key }}"

# Ansible SSH connection settings (optional - defaults to your local username)
# gcp_ansible_user: "pb"  # Must match the username in gcp_ssh_public_keys
# gcp_ansible_ssh_private_key_file: "~/.ssh/id_ed25519"

# PostgreSQL source ranges - includes admin IPs + internal network + app servers
# Admin IPs are centrally managed in all.yml - see admin_ssh_ips variable
# To add non-admin IPs, extend the list like:
#   gcp_postgresql_allowed_sources: "{{ admin_ssh_ips + ['10.0.0.0/8', '35.192.0.0/12', 'YOUR_APP_SERVER_IP/32'] }}"
gcp_postgresql_allowed_sources: "{{ admin_ssh_ips + ['10.0.0.0/8'] }}"

# ============================================================
# POSTGRESQL CONFIGURATION
# ============================================================

# PostgreSQL version
postgresql_version: "17"

# Listen on all interfaces (required for remote connections)
postgresql_listen_addresses: "0.0.0.0"

# Remote access CIDRs (must match gcp_postgresql_allowed_sources)
# Admin IPs are centrally managed in all.yml
# To add non-admin IPs, extend the list to match gcp_postgresql_allowed_sources
postgresql_remote_access_cidrs: "{{ admin_ssh_ips + ['10.0.0.0/8'] }}"

# ============================================================
# SSL/TLS CONFIGURATION
# ============================================================

# Enable SSL for PostgreSQL connections (recommended for production)
postgresql_ssl_enabled: true

# Require SSL for remote connections
postgresql_ssl_require_remote: true

# Generate self-signed certificate (set to false if providing your own)
postgresql_ssl_generate_self_signed: true

# ============================================================
# MULTI-TENANT CONFIGURATION
# ============================================================

# Enable multi-tenant mode (one database per tenant/club)
postgresql_multi_tenant: true

# List of tenants - each gets their own database and user
# Password references should point to vault variables
postgresql_tenants:
  - prefix: "ssc"
    name: "Skyline Soaring Club"
    password: "{{ vault_postgresql_password_ssc }}"

  - prefix: "masa"
    name: "Mid-Atlantic Soaring Association"
    password: "{{ vault_postgresql_password_masa }}"

  # Add more tenants as needed:
  # - prefix: "nfss"
  #   name: "Northern Florida Soaring Society"
  #   password: "{{ vault_postgresql_password_nfss }}"

# ============================================================
# SINGLE-TENANT CONFIGURATION
# ============================================================
# Uncomment these if postgresql_multi_tenant is false

# postgresql_multi_tenant: false
# postgresql_db: "m2s"
# postgresql_user: "m2s"
# postgresql_password: "{{ vault_postgresql_password }}"

# ============================================================
# BACKUP CONFIGURATION
# ============================================================

postgresql_backup_enabled: true
postgresql_backup_retention_days: 7

# CRITICAL: These must be explicitly set to true - role defaults are false!
# Leaving these out causes the backup script to be deployed WITHOUT GCS upload
# or encryption, even if the GCS bucket and passphrase are correctly configured.
postgresql_backup_gcs_enabled: true
postgresql_backup_gcs_bucket: "m2s-database-backups-manage2soar"
postgresql_backup_encryption_enabled: true

# ============================================================
# MEMORY TUNING
# ============================================================
# Adjust based on your VM size

# For e2-small (2GB RAM):
postgresql_shared_buffers: "256MB"
postgresql_effective_cache_size: "768MB"

# For e2-medium (4GB RAM):
# postgresql_shared_buffers: "512MB"
# postgresql_effective_cache_size: "1536MB"

# For larger instances (8GB+ RAM):
# postgresql_shared_buffers: "2GB"
# postgresql_effective_cache_size: "6GB"

# ============================================================
# GCP AUTHENTICATION
# ============================================================
# Choose one authentication method:

# Option 1: Application Default Credentials (recommended)
# Run: gcloud auth application-default login
# No additional config needed - Ansible will use your gcloud credentials

# Option 2: Service Account Key File
# gcp_auth_kind: "serviceaccount"
# gcp_service_account_file: "/path/to/service-account-key.json"
