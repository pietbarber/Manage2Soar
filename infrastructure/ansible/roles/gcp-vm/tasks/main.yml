# GCP VM Provisioning Role - Main Tasks
#
# This role handles:
# 1. Checking if VM already exists
# 2. Creating VM if gcp_vm_provision is true and VM doesn't exist
# 3. Creating/updating firewall rules
# 4. Registering the VM's IP for subsequent roles
---
- name: Validate required GCP variables
  ansible.builtin.assert:
    that:
      - gcp_project is defined
      - gcp_project | length > 0
    fail_msg: |
      GCP project ID is required.
      Please set gcp_project in your group_vars or inventory.

- name: Enable Cloud IAP API for browser SSH access
  ansible.builtin.command:
    cmd: gcloud services enable iap.googleapis.com --project={{ gcp_project }}
  delegate_to: localhost
  become: false
  changed_when: false
  when: gcp_allow_iap_ssh
  tags:
    - gcp-apis

- name: Check if VM already exists
  google.cloud.gcp_compute_instance_info:
    zone: "{{ gcp_zone }}"
    project: "{{ gcp_project }}"
    auth_kind: "{{ gcp_auth_kind | default('application') }}"
    service_account_file: "{{ gcp_service_account_file | default(omit) }}"
  register: existing_vms
  delegate_to: localhost
  become: false

- name: Set VM exists fact
  ansible.builtin.set_fact:
    gcp_vm_exists: "{{ existing_vms.resources | selectattr('name', 'equalto', gcp_vm_name) | list | length > 0 }}"

- name: Display VM status
  ansible.builtin.debug:
    msg: |
      ========================================
      GCP VM Status: {{ gcp_vm_name }}
      ========================================
      VM Exists: {{ gcp_vm_exists }}
      Provision New VM: {{ gcp_vm_provision }}
      {% if gcp_vm_exists %}
      Action: Will use existing VM
      {% elif gcp_vm_provision %}
      Action: Will create new VM
      {% else %}
      Action: ERROR - VM doesn't exist and provisioning is disabled
      {% endif %}
      ========================================

- name: Fail if VM doesn't exist and provisioning is disabled
  ansible.builtin.fail:
    msg: |
      VM '{{ gcp_vm_name }}' does not exist and gcp_vm_provision is false.
      Either create the VM manually or set gcp_vm_provision: true
  when:
    - not gcp_vm_exists
    - not gcp_vm_provision

# ============================================================
# CREATE STATIC IP (if configured)
# ============================================================

- name: Create static IP address
  google.cloud.gcp_compute_address:
    name: "{{ gcp_static_ip_name }}"
    region: "{{ gcp_region }}"
    project: "{{ gcp_project }}"
    auth_kind: "{{ gcp_auth_kind | default('application') }}"
    service_account_file: "{{ gcp_service_account_file | default(omit) }}"
    state: present
  register: gcp_static_address
  delegate_to: localhost
  become: false
  when:
    - gcp_static_ip_name is defined
    - not gcp_vm_exists
    - gcp_vm_provision

# ============================================================
# CREATE VM
# ============================================================

- name: Create GCP VM instance (IPv4 only)
  google.cloud.gcp_compute_instance:
    name: "{{ gcp_vm_name }}"
    machine_type: "{{ gcp_machine_type }}"
    zone: "{{ gcp_zone }}"
    project: "{{ gcp_project }}"
    auth_kind: "{{ gcp_auth_kind | default('application') }}"
    service_account_file: "{{ gcp_service_account_file | default(omit) }}"
    disks:
      - auto_delete: true
        boot: true
        initialize_params:
          source_image: "projects/{{ gcp_image_project }}/global/images/family/{{ gcp_image_family }}"
          disk_size_gb: "{{ gcp_boot_disk_size_gb }}"
          disk_type: "{{ gcp_boot_disk_type }}"
    network_interfaces:
      - network:
          selfLink: "global/networks/{{ gcp_network }}"
        subnetwork: "{{ gcp_subnetwork | default(omit) }}"
        access_configs: "{{ gcp_external_ip | ternary([{'name': 'External NAT', 'nat_ip': (gcp_static_address | default({})).address | default(omit), 'type': 'ONE_TO_ONE_NAT'}], []) }}"
    tags:
      items: "{{ gcp_network_tags }}"
    labels: "{{ gcp_labels }}"
    service_accounts:
      - email: "{{ gcp_service_account_email | default(omit) }}"
        scopes: "{{ gcp_scopes }}"
    metadata: "{{ {'ssh-keys': (gcp_ssh_public_keys | join('\n'))} if gcp_ssh_public_keys | length > 0 else omit }}"
    state: present
  register: gcp_vm_instance
  delegate_to: localhost
  become: false
  when:
    - not gcp_vm_exists
    - gcp_vm_provision
    - not (gcp_enable_ipv6 | default(false) | bool)

# IPv6-enabled VMs require gcloud command as Ansible module doesn't support stack-type
- name: Create GCP VM instance (IPv6 dual-stack)
  ansible.builtin.command:
    cmd: >
      gcloud compute instances create {{ gcp_vm_name }}
      --project={{ gcp_project }}
      --zone={{ gcp_zone }}
      --machine-type={{ gcp_machine_type }}
      --image-family={{ gcp_image_family }}
      --image-project={{ gcp_image_project }}
      --boot-disk-size={{ gcp_boot_disk_size_gb }}GB
      --boot-disk-type={{ gcp_boot_disk_type }}
      --network={{ gcp_network }}
      --subnet={{ gcp_subnetwork }}
      --stack-type=ipv4-ipv6
      --ipv6-network-tier=PREMIUM
      {%- if gcp_external_ip %}
      {%- if gcp_static_address is defined and gcp_static_address.address is defined %}
      --address={{ gcp_static_address.address }}
      {%- endif %}
      {%- else %}
      --no-address
      {%- endif %}
      --tags={{ gcp_network_tags | join(',') }}
      --scopes={{ gcp_scopes | join(',') }}
      {%- if gcp_labels is defined and gcp_labels | length > 0 %}
      --labels={{ gcp_labels | dict2items | map(attribute='key') | zip(gcp_labels | dict2items | map(attribute='value')) | map('join', '=') | join(',') }}
      {%- endif %}
      {%- if gcp_ssh_public_keys is defined and gcp_ssh_public_keys | length > 0 %}
      --metadata=ssh-keys="{{ gcp_ssh_public_keys | join('\n') }}"
      {%- endif %}
      {%- if gcp_service_account_email is defined and gcp_service_account_email | length > 0 %}
      --service-account={{ gcp_service_account_email }}
      {%- endif %}
  register: gcp_vm_instance_ipv6
  delegate_to: localhost
  become: false
  changed_when: gcp_vm_instance_ipv6.rc == 0
  failed_when: >
    gcp_vm_instance_ipv6.rc != 0 and
    'already exists' not in (gcp_vm_instance_ipv6.stderr | default('') | lower)
  when:
    - not gcp_vm_exists
    - gcp_vm_provision
    - gcp_enable_ipv6 | default(false) | bool
    - gcp_subnetwork is defined
    - gcp_subnetwork | length > 0

# ============================================================
# GET EXISTING VM INFO
# ============================================================

- name: Get existing VM details
  ansible.builtin.set_fact:
    gcp_vm_instance: "{{ existing_vms.resources | selectattr('name', 'equalto', gcp_vm_name) | first }}"
  when: gcp_vm_exists

# After IPv6 VM creation, we need to fetch VM details since gcloud doesn't return them
- name: Get VM details after IPv6 creation
  google.cloud.gcp_compute_instance_info:
    zone: "{{ gcp_zone }}"
    project: "{{ gcp_project }}"
    auth_kind: "{{ gcp_auth_kind | default('application') }}"
    service_account_file: "{{ gcp_service_account_file | default(omit) }}"
    filters:
      - "name = {{ gcp_vm_name }}"
  register: new_vm_info
  delegate_to: localhost
  become: false
  when:
    - gcp_vm_instance_ipv6 is defined
    - gcp_vm_instance_ipv6.changed

- name: Set VM instance from new IPv6 VM
  ansible.builtin.set_fact:
    gcp_vm_instance: "{{ new_vm_info.resources | first }}"
  when:
    - new_vm_info is defined
    - new_vm_info.resources is defined
    - new_vm_info.resources | length > 0

# ============================================================
# REGISTER VM IP
# ============================================================

- name: Set VM IP facts
  ansible.builtin.set_fact:
    gcp_vm_internal_ip: "{{ gcp_vm_instance.networkInterfaces[0].networkIP }}"
    gcp_vm_external_ip: "{{ gcp_vm_instance.networkInterfaces[0].accessConfigs | default([]) | map(attribute='natIP') | first | default('N/A', true) }}"
  when: gcp_vm_instance is defined

- name: Display VM network info
  ansible.builtin.debug:
    msg: |
      ========================================
      VM Network Configuration
      ========================================
      VM Name: {{ gcp_vm_name }}
      Internal IP: {{ gcp_vm_internal_ip }}
      External IP: {{ gcp_vm_external_ip }}
      ========================================

# ============================================================
# FIREWALL RULES
# ============================================================

- name: Create PostgreSQL firewall rule
  google.cloud.gcp_compute_firewall:
    name: "{{ gcp_firewall_name_prefix }}-allow-postgresql"
    project: "{{ gcp_project }}"
    auth_kind: "{{ gcp_auth_kind | default('application') }}"
    service_account_file: "{{ gcp_service_account_file | default(omit) }}"
    network:
      selfLink: "global/networks/{{ gcp_network }}"
    allowed:
      - ip_protocol: tcp
        ports:
          - "5432"
    source_ranges: "{{ gcp_postgresql_allowed_sources }}"
    target_tags: "{{ gcp_network_tags }}"
    description: "Allow PostgreSQL connections from trusted sources"
    state: present
  delegate_to: localhost
  become: false
  when: gcp_create_firewall_rules

- name: Create SSH firewall rule
  google.cloud.gcp_compute_firewall:
    name: "{{ gcp_firewall_name_prefix }}-allow-ssh"
    project: "{{ gcp_project }}"
    auth_kind: "{{ gcp_auth_kind | default('application') }}"
    service_account_file: "{{ gcp_service_account_file | default(omit) }}"
    network:
      selfLink: "global/networks/{{ gcp_network }}"
    allowed:
      - ip_protocol: tcp
        ports:
          - "22"
    source_ranges: "{{ gcp_ssh_allowed_sources }}"
    target_tags: "{{ gcp_network_tags }}"
    description: "Allow SSH access for management"
    state: present
  delegate_to: localhost
  become: false
  when: gcp_create_firewall_rules and gcp_allow_ssh and gcp_ssh_allowed_sources | length > 0

- name: Create SSH-from-IAP firewall rule
  google.cloud.gcp_compute_firewall:
    name: "{{ gcp_firewall_name_prefix }}-allow-ssh-from-iap"
    project: "{{ gcp_project }}"
    auth_kind: "{{ gcp_auth_kind | default('application') }}"
    service_account_file: "{{ gcp_service_account_file | default(omit) }}"
    network:
      selfLink: "global/networks/{{ gcp_network }}"
    allowed:
      - ip_protocol: tcp
        ports:
          - "22"
    source_ranges:
      - "{{ gcp_iap_ssh_range }}"
    target_tags: "{{ gcp_network_tags }}"
    description: "Allow SSH from Cloud Identity-Aware Proxy for browser SSH"
    state: present
  delegate_to: localhost
  become: false
  when: gcp_create_firewall_rules and gcp_allow_iap_ssh

- name: Create SMTP firewall rule
  google.cloud.gcp_compute_firewall:
    name: "{{ gcp_firewall_name_prefix }}-allow-smtp"
    project: "{{ gcp_project }}"
    auth_kind: "{{ gcp_auth_kind | default('application') }}"
    service_account_file: "{{ gcp_service_account_file | default(omit) }}"
    network:
      selfLink: "global/networks/{{ gcp_network }}"
    allowed:
      - ip_protocol: tcp
        ports:
          - "587"  # SMTP submission port
          - "25"   # SMTP port
    source_ranges: "{{ gcp_smtp_allowed_sources | default([]) }}"
    target_tags: "{{ gcp_network_tags }}"
    description: "Allow SMTP connections from trusted sources (GKE cluster, application servers)"
    state: present
  delegate_to: localhost
  become: false
  when: gcp_create_firewall_rules and gcp_smtp_allowed_sources is defined and gcp_smtp_allowed_sources | length > 0

# ============================================================
# WAIT FOR VM TO BE READY
# ============================================================

- name: Wait for SSH to become available
  ansible.builtin.wait_for:
    host: "{{ gcp_vm_external_ip }}"
    port: 22
    delay: 10
    timeout: 300
    state: started
  delegate_to: localhost
  become: false
  when:
    - gcp_vm_external_ip is defined
    - gcp_vm_external_ip != 'N/A'
    - not gcp_vm_exists

- name: Add SSH host key to known_hosts
  ansible.builtin.known_hosts:
    path: "~/.ssh/known_hosts"
    name: "{{ gcp_vm_external_ip }}"
    key: "{{ lookup('pipe', 'ssh-keyscan -H ' ~ gcp_vm_external_ip) }}"
    state: present
  delegate_to: localhost
  become: false
  when:
    - gcp_vm_external_ip is defined
    - gcp_vm_external_ip != 'N/A'
    - not gcp_vm_exists

- name: Add new VM to in-memory inventory
  ansible.builtin.add_host:
    name: "{{ gcp_vm_name }}"
    ansible_host: "{{ gcp_vm_external_ip }}"
    ansible_user: "{{ gcp_ansible_user | default(lookup('env', 'USER')) }}"
    ansible_ssh_private_key_file: "{{ gcp_ansible_ssh_private_key_file | default(omit) }}"
    groups:
      # gcp_vm_inventory_group is the preferred name, gcp_target_inventory_group kept for backwards compatibility
      - "{{ gcp_vm_inventory_group | default(gcp_target_inventory_group | default('gcp_servers')) }}"
  when: gcp_vm_external_ip != 'N/A'
