#!/usr/bin/env python3
"""
M2S Mail Alias Sync Script - Generated by Ansible
==================================================
Fetches mailing list membership from M2S API and updates Postfix virtual aliases.

This script is run by cron every 15 minutes.
"""

import grp
import hashlib
import os
import pwd
import re
import shutil
import subprocess
import sys
import tempfile
from datetime import datetime

import requests
import yaml


def load_config():
    """Load configuration from YAML file."""
    config_path = os.path.join(os.path.dirname(__file__), 'config.yml')
    with open(config_path, 'r') as f:
        return yaml.safe_load(f)

# Email validation pattern (RFC 5322 simplified, stricter: no leading/trailing dots)
# Single-char local parts are allowed (e.g., a@domain.com)
EMAIL_PATTERN = re.compile(r'^[a-zA-Z0-9]([a-zA-Z0-9._%+-]*[a-zA-Z0-9])?@[a-zA-Z0-9]([a-zA-Z0-9.-]*[a-zA-Z0-9])?\.[a-zA-Z]{2,}$')


def is_valid_email(email):
    """Validate email format and check for injection characters.

    This prevents malicious recipients from injecting newlines, comments,
    or other control characters into the Postfix virtual alias file.
    """
    if not email or not isinstance(email, str):
        return False
    # Check for injection characters
    if any(c in email for c in '\n\r\t# '):
        return False
    return bool(EMAIL_PATTERN.match(email))


def fetch_club_lists(club, default_auth_token):
    """
    Fetch email lists from M2S API for a club.

    Uses the club's own auth_token if configured, otherwise falls back
    to the default auth_token for backward compatibility.

    Expected response format:
    {
        "lists": {
            "members": ["alice@gmail.com", "bob@yahoo.com", ...],
            "instructors": ["alice@gmail.com", ...],
            "towpilots": ["charlie@outlook.com", ...],
            "board": ["alice@gmail.com", "david@icloud.com", ...]
        },
        "whitelist": ["alice@gmail.com", "bob@yahoo.com", ...]
    }
    """
    try:
        # Use club-specific token if available, otherwise default
        auth_token = club.get('auth_token', default_auth_token)
        headers = {
            'X-API-Key': auth_token,
            'Accept': 'application/json',
        }
        response = requests.get(club['api_url'], headers=headers, timeout=30)
        response.raise_for_status()
        return response.json()
    except requests.RequestException as e:
        print(f"[{datetime.now()}] ERROR: Failed to fetch lists for {club['prefix']}: {e}")
        return None


def generate_virtual_aliases(clubs_data, dev_mode=None):
    """Generate Postfix virtual alias file content.

    If dev_mode is enabled, ALL recipients are redirected to the configured
    dev_mode.redirect_to address. This prevents accidental emails to real
    users during development and testing.
    """
    # Check if dev mode is enabled
    dev_enabled = dev_mode and dev_mode.get('enabled', False)
    dev_redirect = dev_mode.get('redirect_to', '') if dev_mode else ''

    lines = [
        "# ============================================================",
        "# Virtual Aliases - Generated by m2s-sync-aliases.py",
        "# ============================================================",
        f"# Generated: {datetime.now().isoformat()}",
        "# DO NOT EDIT MANUALLY - will be overwritten by cron",
        "",
    ]

    if dev_enabled and dev_redirect:
        lines.append("# *** DEV MODE ENABLED ***")
        lines.append(f"# All mailing list recipients redirected to: {dev_redirect}")
        lines.append("# Set dev_mode.enabled: false in config for production!")
        lines.append("")

    for domain, data in clubs_data.items():
        if not data or 'lists' not in data:
            continue

        lines.append(f"# --- {domain} ---")

        for list_name, recipients in data['lists'].items():
            if recipients:
                if dev_enabled:
                    # DEV MODE: Redirect all recipients to dev address
                    # Defense-in-depth: re-validate dev_redirect even though main() checked it
                    if not is_valid_email(dev_redirect):
                        raise ValueError(f"Invalid dev_redirect email: {dev_redirect}")
                    # Include original recipient count in comment for visibility
                    # Sanitize preview recipients to prevent injection in comment
                    valid_recipients = sorted(set(r for r in recipients if is_valid_email(r)))
                    invalid_count = len(recipients) - len(valid_recipients)
                    preview_recipients = valid_recipients[:3]
                    preview = ','.join(preview_recipients)
                    valid_count = len(valid_recipients)
                    suffix = '...' if valid_count > 3 else ''
                    if invalid_count > 0:
                        lines.append(f"# WARNING: {invalid_count} invalid recipients filtered out")
                    lines.append(f"# Original recipients ({valid_count}): {preview}{suffix}")
                    lines.append(f"{list_name}@{domain}  {dev_redirect}")
                else:
                    # PRODUCTION: Normal recipients - sanitize to prevent injection
                    sanitized = [r for r in recipients if is_valid_email(r)]
                    if not sanitized:
                        # All recipients were filtered out - log warning
                        print(f"[{datetime.now()}] WARNING: {list_name}@{domain} - all {len(recipients)} recipients filtered (invalid emails)")
                        lines.append(f"# WARNING: {list_name}@{domain} - all recipients filtered (invalid emails)")
                    else:
                        recipients_str = ','.join(sorted(set(sanitized)))
                        lines.append(f"{list_name}@{domain}  {recipients_str}")
                        # Add Mailman-style -bounces alias (routes to admin, NOT to list members to avoid bounce storms)
{% if admin_email is defined and admin_email %}
                        lines.append(f"{list_name}-bounces@{domain}  {{ admin_email }}")
{% else %}
                        # admin_email not set; skipping -bounces alias to avoid invalid entry
{% endif %}

        lines.append("")

    return '\n'.join(lines)


def generate_whitelist(clubs_data):
    """Generate Postfix sender whitelist file content."""
    lines = [
        "# ============================================================",
        "# Sender Whitelist - Generated by m2s-sync-aliases.py",
        "# ============================================================",
        f"# Generated: {datetime.now().isoformat()}",
        "# DO NOT EDIT MANUALLY - will be overwritten by cron",
        "",
    ]

    all_senders = set()

    for domain, data in clubs_data.items():
        if data and 'whitelist' in data:
            all_senders.update(data['whitelist'])

    for sender in sorted(all_senders):
        lines.append(f"{sender}  OK")

    return '\n'.join(lines)


def generate_per_club_rspamd_whitelist(club_prefix, whitelist):
    """Generate Rspamd sender whitelist map file content for a single club.

    Per-club whitelists provide tenant isolation - each club's whitelist
    only affects their own domain, preventing a malicious admin from
    whitelisting spammers that could affect other clubs.
    """
    lines = [
        "# ============================================================",
        f"# Rspamd Sender Whitelist for {club_prefix} - Generated by m2s-sync-aliases.py",
        "# ============================================================",
        f"# Generated: {datetime.now().isoformat()}",
        "# DO NOT EDIT MANUALLY - will be overwritten by cron",
        "#",
        "# Whitelisted senders bypass Rspamd spam checks only when SPF returns PASS.",
        "# (SPF PASS requirement prevents spoofing of whitelisted addresses)",
        "# Format: one email address per line",
        "",
    ]

    for sender in sorted(set(whitelist)):
        lines.append(sender)

    return '\n'.join(lines)


def generate_rspamd_whitelist(clubs_data):
    """Generate Rspamd sender whitelist map file content."""
    lines = [
        "# ============================================================",
        "# Rspamd Sender Whitelist - Generated by m2s-sync-aliases.py",
        "# ============================================================",
        f"# Generated: {datetime.now().isoformat()}",
        "# DO NOT EDIT MANUALLY - will be overwritten by cron",
        "#",
        "# Whitelisted senders bypass Rspamd spam checks only when SPF returns PASS.",
        "# (SPF PASS requirement prevents spoofing of whitelisted addresses)",
        "# Format: one email address per line",
        "",
    ]

    all_senders = set()

    for domain, data in clubs_data.items():
        if data and 'whitelist' in data:
            all_senders.update(data['whitelist'])

    for sender in sorted(all_senders):
        lines.append(sender)

    return '\n'.join(lines)


def generate_bypass_lists_map(clubs_bypass_lists):
    """Generate Rspamd bypass lists map file content.

    This file contains recipient patterns (e.g., treasurer@domain.com) for which
    whitelist enforcement is bypassed. These lists can receive mail from anyone
    (still requires SPF PASS, but no sender whitelist check).

    Format: One recipient email pattern per line.
    """
    lines = [
        "# ============================================================",
        "# Bypass Lists - Generated by m2s-sync-aliases.py",
        "# ============================================================",
        f"# Generated: {datetime.now().isoformat()}",
        "# DO NOT EDIT MANUALLY - will be overwritten by cron",
        "#",
        "# Recipients in this list bypass sender whitelist enforcement.",
        "# SPF PASS is still required (prevents spoofing), but any sender",
        "# can email these addresses (useful for service accounts).",
        "# Format: one recipient email per line (e.g., treasurer@domain.com)",
        "",
    ]

    for club_prefix, data in clubs_bypass_lists.items():
        domains = data['domains']
        bypass_lists = data.get('bypass_lists', [])
        if bypass_lists:
            lines.append(f"# {club_prefix} bypass lists")
            for list_name in bypass_lists:
                for domain in domains:
                    lines.append(f"{list_name}@{domain}")

    return '\n'.join(lines)


def generate_recipient_whitelist_check(clubs_data, clubs_bypass_lists):
    """Generate Postfix recipient access restriction file (Issue #533).

    This file maps mailing list recipients to sender whitelist checks.
    Only lists with bypass_whitelist=false are included - those lists
    will REJECT mail from senders not in the whitelist.

    Lists with bypass_whitelist=true (in clubs_bypass_lists) are NOT
    included here, so they accept mail from anyone (for service accounts).

    Format: recipient_email  whitelist_required
    """
    lines = [
        "# ============================================================",
        "# Recipient Whitelist Check - Generated by m2s-sync-aliases.py",
        "# ============================================================",
        f"# Generated: {datetime.now().isoformat()}",
        "# DO NOT EDIT MANUALLY - will be overwritten by cron",
        "#",
        "# This file enforces sender whitelist for mailing lists.",
        "# Only lists with bypass_whitelist=false are included here.",
        "#",
        "# Format: recipient_email  whitelist_required",
        "#",
        "# The whitelist_required restriction class is defined in main.cf as:",
        "#   smtpd_restriction_classes = whitelist_required",
        "#   whitelist_required = check_sender_access hash:/etc/postfix/sender_whitelist, reject",
        "#",
        "# If sender is in whitelist → OK (continue processing)",
        "# If sender is NOT in whitelist → REJECT (554 error)",
        "",
    ]

    # Build set of bypass recipients (lists that accept from anyone)
    bypass_recipients = set()
    for club_prefix, data in clubs_bypass_lists.items():
        domains = data['domains']
        bypass_lists = data.get('bypass_lists', [])
        for list_name in bypass_lists:
            for domain in domains:
                bypass_recipients.add(f"{list_name}@{domain}")

    # Add recipient restrictions for non-bypass lists
    for domain, data in clubs_data.items():
        if not data or 'lists' not in data:
            continue

        lines.append(f"# --- {domain} ---")

        for list_name in data['lists'].keys():
            recipient = f"{list_name}@{domain}"

            # Skip bypass lists (they accept mail from anyone)
            if recipient in bypass_recipients:
                lines.append(f"# {recipient}  (bypass_whitelist=true, accepts from anyone)")
                continue

            # Enforce whitelist for this recipient
            lines.append(f"{recipient}  whitelist_required")

        lines.append("")

    return '\n'.join(lines)


def file_changed(filepath, new_content):
    """Check if file content has changed using hash comparison."""
    if not os.path.exists(filepath):
        return True

    with open(filepath, 'r') as f:
        old_content = f.read()

    old_hash = hashlib.sha256(old_content.encode()).hexdigest()
    new_hash = hashlib.sha256(new_content.encode()).hexdigest()

    return old_hash != new_hash


def write_and_postmap(filepath, content):
    """Write file and run postmap if content changed."""
    if not file_changed(filepath, content):
        return False

    # Write new content
    with open(filepath, 'w') as f:
        f.write(content)

    # Run postmap to rebuild hash database (use full path for cron compatibility)
    subprocess.run(['/usr/sbin/postmap', filepath], check=True)

    return True


def write_rspamd_whitelist(filepath, content):
    """Write Rspamd whitelist file if content changed.

    Uses atomic write via temp file to prevent race conditions where
    Rspamd might read a partially-written file.
    """
    if not file_changed(filepath, content):
        return False

    temp_path = None
    try:
        # Verify directory exists
        dir_path = os.path.dirname(filepath)
        if not os.path.isdir(dir_path):
            print(f"[{datetime.now()}] ERROR: Rspamd whitelist directory does not exist: {dir_path}")
            return False

        # Write to temp file first, then atomic move
        fd, temp_path = tempfile.mkstemp(dir=dir_path)
        try:
            with os.fdopen(fd, 'w') as f:
                f.write(content)

            # Set ownership and permissions before moving
            try:
                rspamd_uid = pwd.getpwnam('_rspamd').pw_uid
                rspamd_gid = grp.getgrnam('_rspamd').gr_gid
                os.chown(temp_path, rspamd_uid, rspamd_gid)
                os.chmod(temp_path, 0o644)
            except KeyError:
                # _rspamd user doesn't exist (maybe on dev machine)
                os.chmod(temp_path, 0o644)

            # Atomic move
            shutil.move(temp_path, filepath)
        except Exception:
            # Clean up temp file on error
            if temp_path and os.path.exists(temp_path):
                os.unlink(temp_path)
            raise

        # Rspamd auto-reloads map files, no need to signal
        return True
    except (IOError, OSError) as e:
        print(f"[{datetime.now()}] ERROR: Failed to write Rspamd whitelist: {e}")
        return False


def ensure_rspamd_whitelist_dir(dir_path):
    """Ensure the Rspamd whitelist directory exists with correct permissions."""
    os.makedirs(dir_path, mode=0o755, exist_ok=True)
    try:
        rspamd_uid = pwd.getpwnam('_rspamd').pw_uid
        rspamd_gid = grp.getgrnam('_rspamd').gr_gid
        os.chown(dir_path, rspamd_uid, rspamd_gid)
    except KeyError:
        pass  # _rspamd user doesn't exist (dev machine)


def main():
    print(f"[{datetime.now()}] Starting M2S mail alias sync...")

    config = load_config()
    default_auth_token = config.get('default_auth_token', config.get('auth_token', ''))
    if not default_auth_token:
        # Check if ALL clubs have their own auth_token
        clubs = config.get('clubs', [])
        missing_tokens = [club['prefix'] for club in clubs if not club.get('auth_token')]
        if missing_tokens:
            print(f"[{datetime.now()}] ERROR: No default_auth_token and clubs missing auth_token: {', '.join(missing_tokens)}")
            sys.exit(1)

    # Fetch lists from all clubs
    clubs_data = {}
    clubs_whitelist_data = {}  # Track per-club whitelist data
    clubs_bypass_lists = {}  # Track per-club bypass lists (Issue #492)
    for club in config['clubs']:
        data = fetch_club_lists(club, default_auth_token)
        if data:
            # Support both single 'domain' and multiple 'domains'
            # This provides backward compatibility with old configs
            domains = club.get('domains')
            if not domains:
                # Backward compatibility: fall back to single 'domain' key
                legacy_domain = club.get('domain')
                if not legacy_domain:
                    print(f"[{datetime.now()}] WARNING: Club {club['prefix']} has no domains configured")
                    continue
                domains = [legacy_domain]

            # Store data for each domain
            for domain in domains:
                clubs_data[domain] = data

            # Use first domain for whitelist tracking (all domains share same whitelist)
            clubs_whitelist_data[club['prefix']] = {
                'domains': domains,
                'whitelist': data.get('whitelist', [])
            }
            # Track bypass lists for this club
            bypass_lists = data.get('bypass_lists', [])
            if bypass_lists:
                clubs_bypass_lists[club['prefix']] = {
                    'domains': domains,
                    'bypass_lists': bypass_lists
                }
                print(f"[{datetime.now()}] Bypass lists for {club['prefix']}: {', '.join(bypass_lists)}")
            print(f"[{datetime.now()}] Fetched {len(data.get('lists', {}))} lists for {club['prefix']} ({len(domains)} domains)")

    if not clubs_data:
        print(f"[{datetime.now()}] WARNING: No club data fetched, keeping existing aliases")
        # Exit with 0 (success) because we intentionally preserved existing aliases.
        # This is a graceful degradation, not a failure - the mail system continues
        # working with the previous alias data. Cron will retry on the next run.
        sys.exit(0)

    # Check for dev mode (safety valve for development)
    dev_mode = config.get('dev_mode', {})
    if dev_mode.get('enabled', False):
        redirect_to = dev_mode.get('redirect_to', '').strip()
        if not redirect_to:
            print(f"[{datetime.now()}] ERROR: dev_mode enabled but no redirect_to address configured!")
            sys.exit(1)
        # Use is_valid_email() for consistent validation
        if not is_valid_email(redirect_to):
            print(f"[{datetime.now()}] ERROR: Invalid dev_mode redirect_to email: {redirect_to}")
            sys.exit(1)
        # Store stripped/validated value in a new dev_mode dict to avoid mutating config.
        # This is safer and more maintainable if config is reused elsewhere.
        dev_mode = {**dev_mode, 'redirect_to': redirect_to}
        print(f"[{datetime.now()}] *** DEV MODE ENABLED ***")
        print(f"[{datetime.now()}] All mailing list recipients will be redirected to: {redirect_to}")

    # Generate and update virtual aliases
    virtual_content = generate_virtual_aliases(clubs_data, dev_mode=dev_mode)
    if write_and_postmap(config['postfix_virtual_file'], virtual_content):
        print(f"[{datetime.now()}] Updated virtual aliases")
    else:
        print(f"[{datetime.now()}] Virtual aliases unchanged")

    # Generate and update whitelist
    whitelist_content = generate_whitelist(clubs_data)
    if write_and_postmap(config['postfix_whitelist_file'], whitelist_content):
        print(f"[{datetime.now()}] Updated sender whitelist")
    else:
        print(f"[{datetime.now()}] Sender whitelist unchanged")

    # Generate and update per-club Rspamd whitelists (if configured)
    if 'rspamd_whitelist_dir' in config:
        whitelist_dir = config['rspamd_whitelist_dir']
        ensure_rspamd_whitelist_dir(whitelist_dir)

        for club_prefix, club_data in clubs_whitelist_data.items():
            whitelist_file = os.path.join(whitelist_dir, f"{club_prefix}_whitelist.map")
            whitelist_content = generate_per_club_rspamd_whitelist(
                club_prefix, club_data['whitelist']
            )
            if write_rspamd_whitelist(whitelist_file, whitelist_content):
                print(f"[{datetime.now()}] Updated Rspamd whitelist for {club_prefix}")
            else:
                print(f"[{datetime.now()}] Rspamd whitelist unchanged for {club_prefix}")

    # Legacy: Also update single combined whitelist if configured (backward compat)
    elif 'rspamd_whitelist_file' in config:
        rspamd_whitelist_content = generate_rspamd_whitelist(clubs_data)
        if write_rspamd_whitelist(config['rspamd_whitelist_file'], rspamd_whitelist_content):
            print(f"[{datetime.now()}] Updated Rspamd whitelist")
        else:
            print(f"[{datetime.now()}] Rspamd whitelist unchanged")

    # Generate and update bypass lists map (Issue #492)
    # This lists recipients that bypass sender whitelist enforcement
    # Always write the file (even when empty) to clear stale data
    if 'rspamd_whitelist_dir' in config:
        bypass_file = os.path.join(config['rspamd_whitelist_dir'], "bypass_lists.map")
        bypass_content = generate_bypass_lists_map(clubs_bypass_lists)
        if write_rspamd_whitelist(bypass_file, bypass_content):
            print(f"[{datetime.now()}] Updated bypass lists map")
        else:
            print(f"[{datetime.now()}] Bypass lists map unchanged")

    # Generate and update Postfix recipient whitelist check (Issue #533)
    # This enforces sender whitelist for mailing lists (reject if sender not whitelisted)
    if 'postfix_recipient_check_file' in config:
        recipient_check_content = generate_recipient_whitelist_check(clubs_data, clubs_bypass_lists)
        if write_and_postmap(config['postfix_recipient_check_file'], recipient_check_content):
            print(f"[{datetime.now()}] Updated recipient whitelist check")
        else:
            print(f"[{datetime.now()}] Recipient whitelist check unchanged")

    print(f"[{datetime.now()}] Sync complete")


if __name__ == '__main__':
    main()
