#!/usr/bin/env python3
"""
M2S Mail Alias Sync Script - Generated by Ansible
==================================================
Fetches mailing list membership from M2S API and updates Postfix virtual aliases.

This script is run by cron every 15 minutes.
"""

import grp
import hashlib
import os
import pwd
import subprocess
import sys
from datetime import datetime

import requests
import yaml


def load_config():
    """Load configuration from YAML file."""
    config_path = os.path.join(os.path.dirname(__file__), 'config.yml')
    with open(config_path, 'r') as f:
        return yaml.safe_load(f)


def fetch_club_lists(club, auth_token):
    """
    Fetch email lists from M2S API for a club.

    Expected response format:
    {
        "lists": {
            "members": ["alice@gmail.com", "bob@yahoo.com", ...],
            "instructors": ["alice@gmail.com", ...],
            "towpilots": ["charlie@outlook.com", ...],
            "board": ["alice@gmail.com", "david@icloud.com", ...]
        },
        "whitelist": ["alice@gmail.com", "bob@yahoo.com", ...]
    }
    """
    try:
        headers = {
            'X-API-Key': auth_token,
            'Accept': 'application/json',
        }
        response = requests.get(club['api_url'], headers=headers, timeout=30)
        response.raise_for_status()
        return response.json()
    except requests.RequestException as e:
        print(f"[{datetime.now()}] ERROR: Failed to fetch lists for {club['prefix']}: {e}")
        return None


def generate_virtual_aliases(clubs_data):
    """Generate Postfix virtual alias file content."""
    lines = [
        "# ============================================================",
        "# Virtual Aliases - Generated by m2s-sync-aliases.py",
        "# ============================================================",
        f"# Generated: {datetime.now().isoformat()}",
        "# DO NOT EDIT MANUALLY - will be overwritten by cron",
        "",
    ]

    for domain, data in clubs_data.items():
        if not data or 'lists' not in data:
            continue

        lines.append(f"# --- {domain} ---")

        for list_name, recipients in data['lists'].items():
            if recipients:
                # Postfix format: alias@domain  recipient1,recipient2,...
                recipients_str = ','.join(sorted(set(recipients)))
                lines.append(f"{list_name}@{domain}  {recipients_str}")

        lines.append("")

    return '\n'.join(lines)


def generate_whitelist(clubs_data):
    """Generate Postfix sender whitelist file content."""
    lines = [
        "# ============================================================",
        "# Sender Whitelist - Generated by m2s-sync-aliases.py",
        "# ============================================================",
        f"# Generated: {datetime.now().isoformat()}",
        "# DO NOT EDIT MANUALLY - will be overwritten by cron",
        "",
    ]

    all_senders = set()

    for domain, data in clubs_data.items():
        if data and 'whitelist' in data:
            all_senders.update(data['whitelist'])

    for sender in sorted(all_senders):
        lines.append(f"{sender}  OK")

    return '\n'.join(lines)


def generate_rspamd_whitelist(clubs_data):
    """Generate Rspamd sender whitelist map file content."""
    lines = [
        "# ============================================================",
        "# Rspamd Sender Whitelist - Generated by m2s-sync-aliases.py",
        "# ============================================================",
        f"# Generated: {datetime.now().isoformat()}",
        "# DO NOT EDIT MANUALLY - will be overwritten by cron",
        "#",
        "# Whitelisted senders bypass all Rspamd spam checks.",
        "# Format: one email address per line",
        "",
    ]

    all_senders = set()

    for domain, data in clubs_data.items():
        if data and 'whitelist' in data:
            all_senders.update(data['whitelist'])

    for sender in sorted(all_senders):
        lines.append(sender)

    return '\n'.join(lines)


def file_changed(filepath, new_content):
    """Check if file content has changed using hash comparison."""
    if not os.path.exists(filepath):
        return True

    with open(filepath, 'r') as f:
        old_content = f.read()

    old_hash = hashlib.sha256(old_content.encode()).hexdigest()
    new_hash = hashlib.sha256(new_content.encode()).hexdigest()

    return old_hash != new_hash


def write_and_postmap(filepath, content):
    """Write file and run postmap if content changed."""
    if not file_changed(filepath, content):
        return False

    # Write new content
    with open(filepath, 'w') as f:
        f.write(content)

    # Run postmap to rebuild hash database
    subprocess.run(['postmap', filepath], check=True)

    return True


def write_rspamd_whitelist(filepath, content):
    """Write Rspamd whitelist file if content changed."""
    if not file_changed(filepath, content):
        return False

    try:
        # Write new content
        with open(filepath, 'w') as f:
            f.write(content)

        # Set ownership to _rspamd user so Rspamd can read the file
        try:
            rspamd_uid = pwd.getpwnam('_rspamd').pw_uid
            rspamd_gid = grp.getgrnam('_rspamd').gr_gid
            os.chown(filepath, rspamd_uid, rspamd_gid)
        except KeyError:
            # _rspamd user doesn't exist (maybe on dev machine)
            pass

        # Rspamd auto-reloads map files, no need to signal
        return True
    except (IOError, OSError) as e:
        print(f"[{datetime.now()}] ERROR: Failed to write Rspamd whitelist: {e}")
        return False


def main():
    print(f"[{datetime.now()}] Starting M2S mail alias sync...")

    config = load_config()

    # Fetch lists from all clubs
    clubs_data = {}
    for club in config['clubs']:
        data = fetch_club_lists(club, config['auth_token'])
        if data:
            clubs_data[club['domain']] = data
            print(f"[{datetime.now()}] Fetched {len(data.get('lists', {}))} lists for {club['prefix']}")

    if not clubs_data:
        print(f"[{datetime.now()}] WARNING: No club data fetched, keeping existing aliases")
        # Exit with 0 (success) because we intentionally preserved existing aliases.
        # This is a graceful degradation, not a failure - the mail system continues
        # working with the previous alias data. Cron will retry on the next run.
        sys.exit(0)

    # Generate and update virtual aliases
    virtual_content = generate_virtual_aliases(clubs_data)
    if write_and_postmap(config['postfix_virtual_file'], virtual_content):
        print(f"[{datetime.now()}] Updated virtual aliases")
    else:
        print(f"[{datetime.now()}] Virtual aliases unchanged")

    # Generate and update whitelist
    whitelist_content = generate_whitelist(clubs_data)
    if write_and_postmap(config['postfix_whitelist_file'], whitelist_content):
        print(f"[{datetime.now()}] Updated sender whitelist")
    else:
        print(f"[{datetime.now()}] Sender whitelist unchanged")

    # Generate and update Rspamd whitelist (if configured)
    if 'rspamd_whitelist_file' in config:
        rspamd_whitelist_content = generate_rspamd_whitelist(clubs_data)
        if write_rspamd_whitelist(config['rspamd_whitelist_file'], rspamd_whitelist_content):
            print(f"[{datetime.now()}] Updated Rspamd whitelist")
        else:
            print(f"[{datetime.now()}] Rspamd whitelist unchanged")

    print(f"[{datetime.now()}] Sync complete")


if __name__ == '__main__':
    main()
