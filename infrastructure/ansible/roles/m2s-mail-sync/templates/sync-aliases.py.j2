#!/usr/bin/env python3
"""
M2S Mail Alias Sync Script - Generated by Ansible
==================================================
Fetches mailing list membership from M2S API and updates Postfix virtual aliases.

This script is run by cron every 15 minutes.
"""

import grp
import hashlib
import os
import pwd
import re
import shutil
import subprocess
import sys
import tempfile
from datetime import datetime

import requests
import yaml


def load_config():
    """Load configuration from YAML file."""
    config_path = os.path.join(os.path.dirname(__file__), 'config.yml')
    with open(config_path, 'r') as f:
        return yaml.safe_load(f)


# Email validation pattern (RFC 5322 simplified)
EMAIL_PATTERN = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')


def is_valid_email(email):
    """Validate email format and check for injection characters.

    This prevents malicious recipients from injecting newlines, comments,
    or other control characters into the Postfix virtual alias file.
    """
    if not email or not isinstance(email, str):
        return False
    # Check for injection characters
    if any(c in email for c in '\n\r\t#'):
        return False
    return bool(EMAIL_PATTERN.match(email))


def fetch_club_lists(club, default_auth_token):
    """
    Fetch email lists from M2S API for a club.

    Uses the club's own auth_token if configured, otherwise falls back
    to the default auth_token for backward compatibility.

    Expected response format:
    {
        "lists": {
            "members": ["alice@gmail.com", "bob@yahoo.com", ...],
            "instructors": ["alice@gmail.com", ...],
            "towpilots": ["charlie@outlook.com", ...],
            "board": ["alice@gmail.com", "david@icloud.com", ...]
        },
        "whitelist": ["alice@gmail.com", "bob@yahoo.com", ...]
    }
    """
    try:
        # Use club-specific token if available, otherwise default
        auth_token = club.get('auth_token', default_auth_token)
        headers = {
            'X-API-Key': auth_token,
            'Accept': 'application/json',
        }
        response = requests.get(club['api_url'], headers=headers, timeout=30)
        response.raise_for_status()
        return response.json()
    except requests.RequestException as e:
        print(f"[{datetime.now()}] ERROR: Failed to fetch lists for {club['prefix']}: {e}")
        return None


def generate_virtual_aliases(clubs_data, dev_mode=None):
    """Generate Postfix virtual alias file content.

    If dev_mode is enabled, ALL recipients are redirected to the configured
    dev_mode.redirect_to address. This prevents accidental emails to real
    users during development and testing.
    """
    # Check if dev mode is enabled
    dev_enabled = dev_mode and dev_mode.get('enabled', False)
    dev_redirect = dev_mode.get('redirect_to', '') if dev_mode else ''

    lines = [
        "# ============================================================",
        "# Virtual Aliases - Generated by m2s-sync-aliases.py",
        "# ============================================================",
        f"# Generated: {datetime.now().isoformat()}",
        "# DO NOT EDIT MANUALLY - will be overwritten by cron",
        "",
    ]

    if dev_enabled and dev_redirect:
        lines.append("# *** DEV MODE ENABLED ***")
        lines.append(f"# All mailing list recipients redirected to: {dev_redirect}")
        lines.append("# Set dev_mode.enabled: false in config for production!")
        lines.append("")

    for domain, data in clubs_data.items():
        if not data or 'lists' not in data:
            continue

        lines.append(f"# --- {domain} ---")

        for list_name, recipients in data['lists'].items():
            if recipients:
                if dev_enabled:
                    # DEV MODE: Redirect all recipients to dev address
                    # Note: dev_redirect is guaranteed valid here (validated in main())
                    # Include original recipient count in comment for visibility
                    preview_recipients = sorted(set(recipients))[:3]
                    preview = ','.join(preview_recipients)
                    suffix = '...' if len(recipients) > 3 else ''
                    lines.append(f"# Original recipients ({len(recipients)}): {preview}{suffix}")
                    lines.append(f"{list_name}@{domain}  {dev_redirect}")
                else:
                    # PRODUCTION: Normal recipients - sanitize to prevent injection
                    sanitized = [r for r in recipients if is_valid_email(r)]
                    if sanitized:
                        recipients_str = ','.join(sorted(set(sanitized)))
                        lines.append(f"{list_name}@{domain}  {recipients_str}")

        lines.append("")

    return '\n'.join(lines)


def generate_whitelist(clubs_data):
    """Generate Postfix sender whitelist file content."""
    lines = [
        "# ============================================================",
        "# Sender Whitelist - Generated by m2s-sync-aliases.py",
        "# ============================================================",
        f"# Generated: {datetime.now().isoformat()}",
        "# DO NOT EDIT MANUALLY - will be overwritten by cron",
        "",
    ]

    all_senders = set()

    for domain, data in clubs_data.items():
        if data and 'whitelist' in data:
            all_senders.update(data['whitelist'])

    for sender in sorted(all_senders):
        lines.append(f"{sender}  OK")

    return '\n'.join(lines)


def generate_per_club_rspamd_whitelist(club_prefix, whitelist):
    """Generate Rspamd sender whitelist map file content for a single club.

    Per-club whitelists provide tenant isolation - each club's whitelist
    only affects their own domain, preventing a malicious admin from
    whitelisting spammers that could affect other clubs.
    """
    lines = [
        "# ============================================================",
        f"# Rspamd Sender Whitelist for {club_prefix} - Generated by m2s-sync-aliases.py",
        "# ============================================================",
        f"# Generated: {datetime.now().isoformat()}",
        "# DO NOT EDIT MANUALLY - will be overwritten by cron",
        "#",
        "# Whitelisted senders bypass Rspamd spam checks only when SPF returns PASS.",
        "# (SPF PASS requirement prevents spoofing of whitelisted addresses)",
        "# Format: one email address per line",
        "",
    ]

    for sender in sorted(set(whitelist)):
        lines.append(sender)

    return '\n'.join(lines)


def generate_rspamd_whitelist(clubs_data):
    """Generate Rspamd sender whitelist map file content."""
    lines = [
        "# ============================================================",
        "# Rspamd Sender Whitelist - Generated by m2s-sync-aliases.py",
        "# ============================================================",
        f"# Generated: {datetime.now().isoformat()}",
        "# DO NOT EDIT MANUALLY - will be overwritten by cron",
        "#",
        "# Whitelisted senders bypass Rspamd spam checks only when SPF returns PASS.",
        "# (SPF PASS requirement prevents spoofing of whitelisted addresses)",
        "# Format: one email address per line",
        "",
    ]

    all_senders = set()

    for domain, data in clubs_data.items():
        if data and 'whitelist' in data:
            all_senders.update(data['whitelist'])

    for sender in sorted(all_senders):
        lines.append(sender)

    return '\n'.join(lines)


def file_changed(filepath, new_content):
    """Check if file content has changed using hash comparison."""
    if not os.path.exists(filepath):
        return True

    with open(filepath, 'r') as f:
        old_content = f.read()

    old_hash = hashlib.sha256(old_content.encode()).hexdigest()
    new_hash = hashlib.sha256(new_content.encode()).hexdigest()

    return old_hash != new_hash


def write_and_postmap(filepath, content):
    """Write file and run postmap if content changed."""
    if not file_changed(filepath, content):
        return False

    # Write new content
    with open(filepath, 'w') as f:
        f.write(content)

    # Run postmap to rebuild hash database (use full path for cron compatibility)
    subprocess.run(['/usr/sbin/postmap', filepath], check=True)

    return True


def write_rspamd_whitelist(filepath, content):
    """Write Rspamd whitelist file if content changed.

    Uses atomic write via temp file to prevent race conditions where
    Rspamd might read a partially-written file.
    """
    if not file_changed(filepath, content):
        return False

    temp_path = None
    try:
        # Verify directory exists
        dir_path = os.path.dirname(filepath)
        if not os.path.isdir(dir_path):
            print(f"[{datetime.now()}] ERROR: Rspamd whitelist directory does not exist: {dir_path}")
            return False

        # Write to temp file first, then atomic move
        fd, temp_path = tempfile.mkstemp(dir=dir_path)
        try:
            with os.fdopen(fd, 'w') as f:
                f.write(content)

            # Set ownership and permissions before moving
            try:
                rspamd_uid = pwd.getpwnam('_rspamd').pw_uid
                rspamd_gid = grp.getgrnam('_rspamd').gr_gid
                os.chown(temp_path, rspamd_uid, rspamd_gid)
                os.chmod(temp_path, 0o644)
            except KeyError:
                # _rspamd user doesn't exist (maybe on dev machine)
                os.chmod(temp_path, 0o644)

            # Atomic move
            shutil.move(temp_path, filepath)
        except Exception:
            # Clean up temp file on error
            if temp_path and os.path.exists(temp_path):
                os.unlink(temp_path)
            raise

        # Rspamd auto-reloads map files, no need to signal
        return True
    except (IOError, OSError) as e:
        print(f"[{datetime.now()}] ERROR: Failed to write Rspamd whitelist: {e}")
        return False


def ensure_rspamd_whitelist_dir(dir_path):
    """Ensure the Rspamd whitelist directory exists with correct permissions."""
    os.makedirs(dir_path, mode=0o755, exist_ok=True)
    try:
        rspamd_uid = pwd.getpwnam('_rspamd').pw_uid
        rspamd_gid = grp.getgrnam('_rspamd').gr_gid
        os.chown(dir_path, rspamd_uid, rspamd_gid)
    except KeyError:
        pass  # _rspamd user doesn't exist (dev machine)


def main():
    print(f"[{datetime.now()}] Starting M2S mail alias sync...")

    config = load_config()
    default_auth_token = config.get('default_auth_token', config.get('auth_token', ''))
    if not default_auth_token:
        # Check if ALL clubs have their own auth_token
        clubs = config.get('clubs', [])
        missing_tokens = [club['prefix'] for club in clubs if not club.get('auth_token')]
        if missing_tokens:
            print(f"[{datetime.now()}] ERROR: No default_auth_token and clubs missing auth_token: {', '.join(missing_tokens)}")
            sys.exit(1)

    # Fetch lists from all clubs
    clubs_data = {}
    clubs_whitelist_data = {}  # Track per-club whitelist data
    for club in config['clubs']:
        data = fetch_club_lists(club, default_auth_token)
        if data:
            clubs_data[club['domain']] = data
            clubs_whitelist_data[club['prefix']] = {
                'domain': club['domain'],
                'whitelist': data.get('whitelist', [])
            }
            print(f"[{datetime.now()}] Fetched {len(data.get('lists', {}))} lists for {club['prefix']}")

    if not clubs_data:
        print(f"[{datetime.now()}] WARNING: No club data fetched, keeping existing aliases")
        # Exit with 0 (success) because we intentionally preserved existing aliases.
        # This is a graceful degradation, not a failure - the mail system continues
        # working with the previous alias data. Cron will retry on the next run.
        sys.exit(0)

    # Check for dev mode (safety valve for development)
    dev_mode = config.get('dev_mode', {})
    if dev_mode.get('enabled', False):
        redirect_to = dev_mode.get('redirect_to', '')
        if redirect_to:
            # Basic email validation
            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            if not re.match(email_pattern, redirect_to):
                print(f"[{datetime.now()}] ERROR: Invalid dev_mode redirect_to email: {redirect_to}")
                sys.exit(1)
            print(f"[{datetime.now()}] *** DEV MODE ENABLED ***")
            print(f"[{datetime.now()}] All mailing list recipients will be redirected to: {redirect_to}")
        else:
            print(f"[{datetime.now()}] ERROR: dev_mode enabled but no redirect_to address configured!")
            sys.exit(1)

    # Generate and update virtual aliases
    virtual_content = generate_virtual_aliases(clubs_data, dev_mode=dev_mode)
    if write_and_postmap(config['postfix_virtual_file'], virtual_content):
        print(f"[{datetime.now()}] Updated virtual aliases")
    else:
        print(f"[{datetime.now()}] Virtual aliases unchanged")

    # Generate and update whitelist
    whitelist_content = generate_whitelist(clubs_data)
    if write_and_postmap(config['postfix_whitelist_file'], whitelist_content):
        print(f"[{datetime.now()}] Updated sender whitelist")
    else:
        print(f"[{datetime.now()}] Sender whitelist unchanged")

    # Generate and update per-club Rspamd whitelists (if configured)
    if 'rspamd_whitelist_dir' in config:
        whitelist_dir = config['rspamd_whitelist_dir']
        ensure_rspamd_whitelist_dir(whitelist_dir)

        for club_prefix, club_data in clubs_whitelist_data.items():
            whitelist_file = os.path.join(whitelist_dir, f"{club_prefix}_whitelist.map")
            whitelist_content = generate_per_club_rspamd_whitelist(
                club_prefix, club_data['whitelist']
            )
            if write_rspamd_whitelist(whitelist_file, whitelist_content):
                print(f"[{datetime.now()}] Updated Rspamd whitelist for {club_prefix}")
            else:
                print(f"[{datetime.now()}] Rspamd whitelist unchanged for {club_prefix}")

    # Legacy: Also update single combined whitelist if configured (backward compat)
    elif 'rspamd_whitelist_file' in config:
        rspamd_whitelist_content = generate_rspamd_whitelist(clubs_data)
        if write_rspamd_whitelist(config['rspamd_whitelist_file'], rspamd_whitelist_content):
            print(f"[{datetime.now()}] Updated Rspamd whitelist")
        else:
            print(f"[{datetime.now()}] Rspamd whitelist unchanged")

    print(f"[{datetime.now()}] Sync complete")


if __name__ == '__main__':
    main()
