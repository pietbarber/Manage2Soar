# Kubernetes Deployment and Service for Django Application
# Generated by Ansible gke-deploy role
# DO NOT EDIT MANUALLY - managed by Ansible
#
# Tenant: {{ gke_club_prefix | default('default') }}
# Generated: {{ ansible_date_time.iso8601 | default(lookup('pipe', 'date -Iseconds')) }}

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ gke_deployment_name }}
  namespace: {{ gke_namespace }}
  labels:
    app: {{ gke_deployment_name }}
{% if gke_multi_tenant %}
    tenant: {{ gke_club_prefix }}
{% endif %}
  annotations:
    app.kubernetes.io/version: "{{ gke_computed_image_tag | trim }}"
spec:
  replicas: {{ gke_replicas }}
  selector:
    matchLabels:
      app: {{ gke_deployment_name }}
{% if gke_multi_tenant %}
      tenant: {{ gke_club_prefix }}
{% endif %}
  template:
    metadata:
      labels:
        app: {{ gke_deployment_name }}
{% if gke_multi_tenant %}
        tenant: {{ gke_club_prefix }}
{% endif %}
      annotations:
        # Force pod restart on config change
        checksum/config: "{{ (gke_computed_image_tag | trim) | hash('sha256') }}"
    spec:
      containers:
        - name: django
          image: {{ gke_image_name }}:{{ gke_computed_image_tag | trim }}
          imagePullPolicy: Always
          workingDir: /app
          ports:
            - containerPort: {{ gke_container_port }}
              protocol: TCP
          env:
            - name: GOOGLE_APPLICATION_CREDENTIALS
              value: {{ gke_gcp_credentials_path }}
          envFrom:
            - secretRef:
                name: {{ gke_secret_name }}
          volumeMounts:
            - name: static-files
              mountPath: /app/static
            - name: media-files
              mountPath: /app/media
            - name: gcp-sa-key
              mountPath: {{ gke_gcp_credentials_path }}
              subPath: {{ gke_gcp_credentials_filename }}
              readOnly: true
          resources:
            requests:
              memory: "{{ gke_memory_request }}"
              cpu: "{{ gke_cpu_request }}"
            limits:
              memory: "{{ gke_memory_limit }}"
              cpu: "{{ gke_cpu_limit }}"
          # Health checks: Using TCP socket probes temporarily - NOT production-ready!
          # TODO: Implement /health/ endpoint in Django that validates DB connectivity before production use.
          # RISK: TCP probes only verify port is open, not that Django is functional or can connect to database.
          # A pod with database connection failures or Django crashes could still be marked healthy and receive traffic.
          livenessProbe:
            tcpSocket:
              port: {{ gke_container_port }}
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
          readinessProbe:
            tcpSocket:
              port: {{ gke_container_port }}
            initialDelaySeconds: 10
            periodSeconds: 5
            timeoutSeconds: 3
            failureThreshold: 3
      volumes:
        - name: static-files
          emptyDir: {}
        - name: media-files
          emptyDir: {}
        - name: gcp-sa-key
          secret:
            secretName: {{ gke_gcp_sa_secret_name }}

---
apiVersion: v1
kind: Service
metadata:
  name: {{ gke_service_name }}
  namespace: {{ gke_namespace }}
  labels:
    app: {{ gke_deployment_name }}
{% if gke_multi_tenant %}
    tenant: {{ gke_club_prefix }}
{% endif %}
  annotations:
    cloud.google.com/backend-config: '{"default": "{{ gke_deployment_name }}-config"}'
spec:
  type: NodePort
  selector:
    app: {{ gke_deployment_name }}
{% if gke_multi_tenant %}
    tenant: {{ gke_club_prefix }}
{% endif %}
  ports:
    - protocol: TCP
      port: {{ gke_container_port }}
      targetPort: {{ gke_container_port }}
